#LyX 2.0.0beta4 created this file. For more info see http://www.lyx.org/
\lyxformat 412
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{fullpage}
%\usepackage{framed}
\usepackage{listings}
\usepackage{fix-cm}

% bold ttfonts
\usepackage{courier}
\renewcommand{\ttdefault}{pcr}

\lstset{%
language=C, 
numbers=left, 
frame=single, 
xleftmargin=20pt, 
xrightmargin=40pt, 
basicstyle=\ttfamily \small, 
tabsize=2 %
}

\newenvironment{boa}
{% This is the begin code
  \begin{minipage}[t]{0.9\columnwidth}%
  %  \begin{framed}
  \footnotesize 
  \ttfamily    
}
{% This is the end code
  %  \end{framed}
  \end{minipage}
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
fontsize{40}{40}
\backslash
selectfont 
\backslash
bfseries boa}
\backslash

\backslash

\end_layout

\end_inset

 
\begin_inset VSpace bigskip
\end_inset


\begin_inset Graphics
	filename ../boa.png
	lyxscale 33
	height 50pt

\end_inset


\series bold
\size giant

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\series default
\size default

\begin_inset VSpace bigskip
\end_inset

Buffer Overrun Analyzer
\end_layout

\begin_layout Author
Edo Cohen
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
 039374814 
\backslash

\backslash
 sedoc@t2 
\backslash
and 
\end_layout

\end_inset

Tzafrir Rehan
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
 039811880 
\backslash

\backslash
 tzafrir@cs 
\backslash
and 
\end_layout

\end_inset

Gai Shaked
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
 036567055 
\backslash

\backslash
 gai@tx
\end_layout

\end_inset


\end_layout

\begin_layout Date

\size larger
\begin_inset VSpace 5pheight%
\end_inset

Project in advanced programming - program analysis (236503)
\begin_inset Newline newline
\end_inset


\size default

\begin_inset VSpace medskip
\end_inset

Computer science department, Technion - Israel institute of technology
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Goal
\end_layout

\begin_layout Standard
Given a C program that performs buffer manipulations, statically identify
 whether the program may perform array access out of the array bounds.
\end_layout

\begin_layout Chapter
boa
\begin_inset CommandInset label
LatexCommand label
name "chap:boa"

\end_inset


\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename flow.png
	width 100text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Main components and stages
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Constraint Generator
\end_layout

\begin_layout Subsection
Integers 
\end_layout

\begin_layout Subsection
Direct array access
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=4,lastline=5]{../tests/testcases/simple3.c}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
String manipulation functions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=1,lastline=15]{../tests/testcases/string1.c}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Buffer aliasing
\end_layout

\begin_layout Section
Linear Solver
\end_layout

\begin_layout Standard
The constraints generated represent a linear problem, and each solution
 of the problem suggests a set of ranges for the values each integer may
 recieve and the allocation and usage of each buffer.
 As we aim to find the tightest ranges, we direct our linear solver to find
 a solution maximizing -
\begin_inset Formula 
\[
Goal=\sum_{\mathbf{Buffers}}\left[\left\{ \mbox{buf!used!min}\right\} \stackrel{\phantom{+}}{+}\left\{ \mbox{buf!alloc!min}\right\} -\left\{ \mbox{buf!used!max}\right\} -\left\{ \mbox{buf!alloc!max}\right\} \right]
\]

\end_inset

A solution satisfying this goal will maximize the lower bounds and minimize
 the upper bounds of each buffer access, and thus assure we get the tightest
 solution.
\end_layout

\begin_layout Standard
Once we have the solution
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The solution is a set of integer values, one for each of the problem variables,
 such that all the constraints are satisfied and the 
\begin_inset Formula $Goal$
\end_inset

 value is maximized
\end_layout

\end_inset

 we test each buffer to verify that - 
\begin_inset Formula 
\[
\left\{ \mbox{buf!used}\right\} \subseteq\left\{ \mbox{buf!alloc}\right\} 
\]

\end_inset

Which means - 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf!used!max}\right\}  & < & \left\{ \mbox{buf!alloc!min}\right\} \\
\left\{ \mbox{buf!used!min}\right\}  & \ge & 0
\end{eqnarray*}

\end_inset

Note that we stick to the size and numbering conventions of C, safe access
 to a buffer of size 
\begin_inset Formula $n$
\end_inset

 is any access to the cells 
\begin_inset Formula $0\dots n-1$
\end_inset

.
 If the solution does not satisfy one of the constraints, we report a possible
 buffer overrun in this specific buffer.
 
\end_layout

\begin_layout Subsection
Handling infeasible problems
\end_layout

\begin_layout Standard
In many cases, the constraints we generate create an infeasible linear problem.
 The simplest example of such case is - 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

int i;
\end_layout

\begin_layout Plain Layout

i++;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

The constraint generated from the second line will be - 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{tmp!max}\right\}  & \ge & \left\{ \mbox{i!max}\right\} +1\\
\left\{ \mbox{i!max}\right\}  & \ge & \left\{ \mbox{tmp!max}\right\} 
\end{eqnarray*}

\end_inset

Which is obviously an infeasible set of constraints.
 The same problem holds in many different cases, including 
\emph on
strcat
\emph default
 (which concatenates one string to the end of another, and therefore implies
 an equivalent set of constraints to the string used length).
\end_layout

\begin_layout Standard
When our linear solver discovers that the constraints problem we have generated
 is infeasible, we wish make the smallest change to the problem and make
 it feasible once again.
 There is a great body of work in the area of finding and eliminating IIS
 (
\emph on
irreducibly inconsistent system
\emph default
), and we follow the algorithms and terminology of Chinneck and Dravnieks
\begin_inset CommandInset citation
LatexCommand cite
key "Elastic IIS"

\end_inset

.
 The common and naive approach is the deletion filtering -
\end_layout

\begin_layout Enumerate
input: 
\begin_inset Formula $Q$
\end_inset

 is an infeasible set of constraints
\end_layout

\begin_layout Enumerate
[try to delete] FOREACH 
\begin_inset Formula $q_{i}\in Q$
\end_inset

 DO:
\end_layout

\begin_deeper
\begin_layout Enumerate
Test whether 
\begin_inset Formula $Q\backslash q_{i}$
\end_inset

 is feasible -
\end_layout

\begin_deeper
\begin_layout Enumerate
IF infeasible - set 
\begin_inset Formula $Q=Q\backslash q_{i}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset Formula $Q$
\end_inset

 is an IIS
\end_layout

\begin_layout Standard
After one iteration the algorithm return an IIS, which can be removed from
 the original problem.
 In case there are several IISs in the original problem - the algorithm
 should repeat until the problem become feasible.
 We have implemented this approch at first, and it did work well on small
 pieces of code, but naturally did not scale well - on the same testing
 system described in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Results"

\end_inset

 it took more than half an hour to eliminate the IISs in the 400 lines of
 source of 
\emph on
md5
\emph default
 library, and more than 8 hours to find the blames (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Blame-system"

\end_inset

) as well.
 Therefore we read furthr and implemented an elastic filter for eliminating
 IIS.
 
\end_layout

\begin_layout Subsubsection
Elastic filter
\end_layout

\begin_layout Standard
The main idea behind elastic filtering is adding a new 
\emph on
elastic variable
\emph default
 to each constraint, allowing it to 
\emph on
strech
\emph default
 and therefore the infeasibility removed, than we solve the new problem,
 trying to minimize effect of the 
\emph on
elastic variables
\emph default
 and each elastic variable assigned a non-zero value marks a constraint
 which is part on an IIS.
 Formally - 
\end_layout

\begin_layout Enumerate
Initialize 
\begin_inset Formula $S=\emptyset$
\end_inset

 (will hold the IIS)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Q$
\end_inset

 is an infeasible set of constraints of the form - 
\begin_inset Formula 
\[
q_{i}:\sum_{j=1}^{n_{i}}a_{i_{j}}X_{i_{j}}\ge c_{i}
\]

\end_inset

where 
\begin_inset Formula $a_{i_{j}},c_{i}$
\end_inset

 are constants and 
\begin_inset Formula $X_{i_{j}}$
\end_inset

 is a variable of the constraint problem.
\end_layout

\begin_layout Enumerate
Add an 
\emph on
elastic variable
\emph default
 
\begin_inset Formula $e_{i}$
\end_inset

 to each constreaint 
\begin_inset Formula $q_{i}\in Q$
\end_inset

 such that - 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $q_{i}:\sum_{j=1}^{n_{i}}a_{i_{j}}X_{i_{j}}+e_{i}\ge c_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
Limit the elastic variables to accept non-negative values, and set the goal
 of the linear problem to minimize the sum of the elastic variables - 
\begin_inset Formula $Goal=-\sum e_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
WHILE the problem is feasible - 
\end_layout

\begin_deeper
\begin_layout Enumerate
Solve the linear problem, for each elastic variable 
\begin_inset Formula $e_{i}$
\end_inset

 - 
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\begin_inset Formula $e_{i}>0$
\end_inset

 - 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $S=S\cup\left\{ q_{i}\right\} $
\end_inset

 
\end_layout

\begin_layout Enumerate
remove 
\begin_inset Formula $e_{i}$
\end_inset

 (
\begin_inset Formula $q_{i}:\sum_{j=1}^{n_{i}}a_{i_{j}}X_{i_{j}}\ge c_{i}$
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
return 
\begin_inset Formula $S$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
The most time consuming part of the process is trying to solve the constraint
 problem (the linear solver use simplex
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
TODO (Gai) - simplex reference
\end_layout

\end_inset

).
 The delete filter tries to solve 
\begin_inset Formula $n$
\end_inset

 problems (
\begin_inset Formula $n$
\end_inset

 - the number of constraints in the original problem) and return one IIS.
 On the other hand - the elastic filter perform only 
\begin_inset Formula $m$
\end_inset

 iterations (
\begin_inset Formula $m$
\end_inset

 - the number of constraints in the smaller IIS in the problem), and return
 
\begin_inset Formula $m$
\end_inset

 constraints of each of the IISs in the problem.
 A typical IIS in the problems generated by our constraint generator consist
 of 3 or 4 constraints, thus we have predicted the performence of the elastic
 filter will be mush better than the deleting filter, and indeed (as we
 describe in detail in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Results"

\end_inset

) the results achived using the elastic filter were much better.
 
\end_layout

\begin_layout Subsubsection
Removing constraints
\end_layout

\begin_layout Section
Blame system
\begin_inset CommandInset label
LatexCommand label
name "sub:Blame-system"

\end_inset


\end_layout

\begin_layout Standard
In order to make boa useful we aim not only to inform the programmer about
 possible overruns, but also to direct him into the problematic code, which
 made boa generate the warning in the first place.
 We call this feature 
\emph on
blame, 
\emph default
since it allows boa to blame specific operatonios in specific source lines,
 allowing the programmer to examine each warning quickly and understand
 whether there is a real overrun in the code or the warning is a false alarm.
 
\end_layout

\begin_layout Standard
As far as we know, previous works in this area did not deal with this issue
 (
\begin_inset CommandInset citation
LatexCommand cite
key "BOON"

\end_inset

) or used third party tool in order to provide the user with all of the
 code references to the suspect buffer (
\begin_inset CommandInset citation
LatexCommand cite
key "הודים"

\end_inset

).
 
\end_layout

\begin_layout Standard
The input for our blame system is a list of 
\emph on
unsafe buffers
\emph default
, buffers in which the linear solver detected a possible overrun.
 For each of the unsafe buffers the output is a set of constraints, this
 set should be the minimal nessecary set of constraints for the generation
 of the overrun.
 
\end_layout

\begin_layout Standard
Note that the definition of this set resembles the definition of an IIS
 - in both cases we look for a minimal set of constraints which imply a
 global property of the constraints problem.
 Therefore we based or blaming system on reducing the blaming problem to
 the problem of finding an IIS, and then using the existing algorithms to
 find the desired set of constraints.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Chapter
Development Process
\end_layout

\begin_layout Section
Initial Requirements
\end_layout

\begin_layout Standard
We set out to develop Boa by first defining a preliminary set of requirements:
\end_layout

\begin_layout Itemize
Provide analysis over any valid
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We define 
\size normal
\emph on
Valid C
\emph default
 code as any code that is compiled by 
\emph on
gcc
\emph default
 with the 
\emph on
-Wall
\emph default
 flag without any warnings.
\end_layout

\end_inset

 C code as is, without requiring the programmer to provide any meta information.
\end_layout

\begin_layout Itemize
Provide 
\emph on
Soundness
\emph default
: Report 100% of the buffer overruns in the code, with no 
\emph on
False Negatives
\emph default
 reported.
\end_layout

\begin_layout Standard
We also had a goal of minimizing false positives, for which we couldn't
 define a measurable requirement at the initial stage.
\end_layout

\begin_layout Section
Lenient Assumptions
\end_layout

\begin_layout Standard
In order to achieve these requirements we also defined lenient assumption
 on the input code:
\end_layout

\begin_layout Itemize
The programmer knows that the C string library requires that a string must
 end with the NUL terminating character '
\backslash
0', and will never mutate the last byte of a buffer in a way that will cause
 an overrun.
\end_layout

\begin_layout Itemize
The programmer never uses an uninitialized value.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO(tzafrir): Find more assumptions we used, if any.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Research and Technology Survey
\end_layout

\begin_layout Standard
After defining the initial requirements we began researching past work on
 the subject of buffer overrun static analysis, and set out to find which
 tools already exist that can be used to build Boa.
\end_layout

\begin_layout Standard
Our research reached the conclusion of using a linear problem solver, solving
 a set of linear constraints generated from each instruction in the source
 code, in order to find buffer overruns, as described in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:boa"

\end_inset

.
\end_layout

\begin_layout Standard
We set a goal of using only open source tools which are publically available
 for free use under an Open-Source compatible license, and converged towards
 the use of the following tools:
\end_layout

\begin_layout Itemize
GLPK - the GNU Linear Programming Kit [
\begin_inset CommandInset href
LatexCommand href
target "http://www.gnu.org/software/glpk/glpk.html"

\end_inset

], available under version 3 of the GNU Public License.
 Used to solve the linear constraints using the Simplex Algorithm.
\end_layout

\begin_layout Itemize
The Clang C Front-End [
\begin_inset CommandInset href
LatexCommand href
name "http://clang.llvm.org/"
target "http://clang.llvm.org/"

\end_inset

], available under the University of Illinois/NCSA Open Source License.
 We planned on using Clang's plug-in system in order to go over the code's
 Abstract Syntax Tree and generate linear constraints according to the instructi
ons in the code.
\end_layout

\begin_layout Standard
We then set out to create prototypes.
 First we created example, 
\begin_inset Quotes eld
\end_inset


\emph on
Hello World
\begin_inset Quotes erd
\end_inset


\emph default
 style, programs that make use of Clang and GLPK's interfaces separately,
 and then combined the two prototypes to a single system that works according
 to our system design, produces constraints by traversing the source code,
 solves the constraints system and reports buffer overruns accordingly.
\end_layout

\begin_layout Standard
At this stage we created constraints such that any buffer access and use
 and any function call created an overrun on all buffers involved.
 This trivial handling already meets our well defined requirements of handling
 any C source code and being 
\emph on
Sound
\emph default
, and from this point we began iterating on reducing false positives.
\end_layout

\begin_layout Standard
This methodology allowed us to have at any given point a sound working system
 which gained quality as the construction progressed.
\end_layout

\begin_layout Section
Test system
\end_layout

\begin_layout Standard
To facilitate the construction of Boa, we worked using 
\emph on
Test Driven Development
\emph default
.
 Since our entire system is hosted as a Clang plugin, for most purposes
 
\emph on
White Box
\emph default
 testing was not reasonable for our purposes.
\end_layout

\begin_layout Standard
We therefore created a 
\emph on
Black Box
\emph default
 testing system which allowed us to write tests for the full system behaviour.
\end_layout

\begin_layout Standard
A test case is comprised of a source code (.c file) and assertions (.asserts
 file), which define which buffers should be marked as having overruns,
 and which buffers should be marked as safe.
 Buffers may be defined by their name, by their source code location, or
 by both.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard

\emph on
integer03.c:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../tests/testcases/integer03.c}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(Gai)
\end_layout

\begin_layout Plain Layout
This is not a good example, the reader won't see the overrun caused by i++
 (executed once!).
 Since we do not aim to explain this behaviour here - we should choose another
 test (or set i=9 at the begining).
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
integer03.asserts:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{../tests/testcases/integer03.asserts}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We then wrapped this testing system with scripts that run the tests over
 all available test cases and indicate failure if any test case failed,
 and incorporated this script into our makefile, such that running 
\emph on
make tests
\emph default
 compiles binaries as necessary and runs the tests on the result.
 This allows us to run all our tests after every change in the code, thus
 giving us confidence that old behaviour is not broken, and allowing us
 to start developing a feature by first defining a failing test case, then
 writing code until the test passes.
\end_layout

\begin_layout Section
Version Control
\end_layout

\begin_layout Standard
We used 
\emph on
git
\emph default
 as our versioning control system.
 We leveraged the distributed nature of git and the cheap branching of git
 to create a workflow based on 
\emph on
feature branches
\emph default
, where each of us worked on a feature on a separate branch of the code,
 which was later merged into our integration branch, 
\emph on

\begin_inset Quotes eld
\end_inset

master
\begin_inset Quotes erd
\end_inset


\emph default
.
\end_layout

\begin_layout Subsection
Online Hosting
\end_layout

\begin_layout Standard
We used Github as an online code repository.
 This also gave us basic project management tools such as issue tracking
 and code reviews.
\end_layout

\begin_layout Subsection
Code Reviews
\end_layout

\begin_layout Standard
Github allows developers to send each other code reviews (named 
\emph on
Pull Requests
\emph default
 in git terminology).
 We embraced this feature into our work flow such that all of the code that
 goes into 
\emph on
master
\emph default
 has to be reviewed by a team member.
\end_layout

\begin_layout Standard
For each code review, one of the team members which did not write the code
 would read the code and a discussion would start, where the reviewer requested
 improvement to the code, tests or documentation such that the code is correct
 and readable.
 By using this workflow, we ensured that the final code is not only correct,
 but also readable, since each code snippet had to be read by a programmer
 that did not see the code being written before being integrated into 
\emph on
master
\emph default
.
\end_layout

\begin_layout Section
Construction
\end_layout

\begin_layout Standard
During the Construction phase we used the following workflow:
\end_layout

\begin_layout Itemize
Create a local branch which is a copy of 
\emph on
master
\emph default
.
\end_layout

\begin_layout Itemize
Write a failing test case.
\end_layout

\begin_layout Itemize
Write code that handles the failures of the test case, detects all possible
 overruns and does not report a false positive where not needed, until the
 test passes.
\end_layout

\begin_layout Itemize
Upload the branch to the online repository.
\end_layout

\begin_layout Itemize
Send a 
\emph on
Pull Request
\emph default
 to the team.
\end_layout

\begin_layout Itemize
Repeat.
\end_layout

\begin_layout Standard

\emph on
Git
\emph default
's distributed nature allowed us to use this workflow with minimal overhead
 - On the one hand, orthogonal changes could be developed in parallel, with
 one programmer usually working on more than one change simultaneously in
 different branches.
 On the other hand, when programmer A needed to base his changes on code
 written by programmer B which was not yet reviewed and integrated, he could
 pull the work-in-progress branch from A's repository and base his own work
 without being blocked by the review process.
 
\emph on
Git
\emph default
 also makes it easy to later merge additional changes made by programmer
 B (for example, as a result of the code review process).
\end_layout

\begin_layout Section
Porting To LLVM
\end_layout

\begin_layout Standard
After we developed some initial features such as generating constraints
 according to integer arithmetic instructions, we began seeing some difficulties
 with our use of the Clang front-end as our constraint generation mechanism:
\end_layout

\begin_layout Itemize
The representation of various instructions are scattered across many nodes
 in Clang's representation of the AST, which made it hard to write generalized
 code that handles multiple cases.
\end_layout

\begin_layout Itemize
Clang's 
\emph on
RecursiveASTVisitor
\emph default
 implementation has only been written recently, and as cutting edge code
 it proved to be somewhat uncomfortable to work with.
\begin_inset Note Comment
status open

\begin_layout Plain Layout
TODO(tzafrir): Find examples for this
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also, working directly on the AST of a high level language meant that the
 space of instructions that Boa needs to handle is quite large.
\end_layout

\begin_layout Standard
We therefore decided it would be best to first compile the code into LLVM
 bitcode, and then generate constraints according to that bitcode using
 an 
\emph on
LLVM Pass
\emph default
.
\end_layout

\begin_layout Standard
We first prototyped an LLVM pass in the same manner we prototyped Clang,
 and then rebased Boa to use LLVM instead of clang in its architecture.
 All of our test cases were still valid (and at this stage, failing), so
 we continued our construction cycle, iterating until all existing test
 cases pass, usually using the previously written code as a reference as
 to how to handle a certain instruction (e.g., the constraints generated for
 a multiplication of two integers).
\end_layout

\begin_layout Standard
Within two weeks all our existing test cases passed
\begin_inset Note Note
status open

\begin_layout Plain Layout
(Gai) mention uninitialize?
\end_layout

\end_inset

, and we could refocus on further reducing false positives.
\end_layout

\begin_layout Standard
Having specific test cases defining the required handling of specific C
 instructions, a modular design where the mathematical work surrounding
 solving a linear constraint problem is separated from the handling of source
 code instructions, and the encapsulation of our algorithmic code all allowed
 us to very easily handle this major change in our system architecture,
 without having to rewrite the entire system from scratch.
\end_layout

\begin_layout Chapter
Results
\begin_inset CommandInset label
LatexCommand label
name "chap:Results"

\end_inset


\end_layout

\begin_layout Standard
We tested boa on several widespread real world programs.
 We tested to see whether boa discovers real buffer overruns, and also to
 evaluate the number of false alarms and their main causes.
 The source files used in all of the experiments are availble in boa git
 repository
\begin_inset CommandInset citation
LatexCommand cite
key "git repository"

\end_inset

.
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Performance"

\end_inset

 summarizes the performance of boa on several programs, the reported running
 times are the results of experiments ran on a Dell Vostro 1310 laptop,
 with Intel Core2 Duo CPU T8100 2.10GHz and 2GB RAM running Debian GNU/Linux
 Wheezy (7.0.0), clang 2.9, llvm 2.9 and GLPK 4.43.
 On this humble configuration boa can analyze few thousands lines of code
 within seconds, thus the use of elastic filter did pay off and boa can
 be used to efficiently analyze any reasonable piece of C code.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fingerd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
flex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
syslog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ssh
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
md5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Source lines
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
332
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3483
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
432
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constraints
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2894
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1206
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7642
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Running time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.608s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Running time (blame)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.508s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.304s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20.049s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Buffers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
92
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Overruns reported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Real overruns
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Performance"

\end_inset

boa performance on various real world examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Over the next sections we will present and describe in details some of the
 possible overruns boa detected in these programs, and use these examples
 to demonstrate how boa can be used to detect overruns and how one can analyze
 false alarms.
\end_layout

\begin_layout Section
fingerd
\end_layout

\begin_layout Standard
We tested boa using 
\emph on
fingerd
\emph default
, unix finger deamon.
 We altered the current source code to reflect the well known buffer overrun,
 used by the 
\emph on
Internet worm
\emph default
 in 1988.
 The overrun is caused by using the unsafe function 
\emph on
gets
\emph default
 to read data into the 1024
\begin_inset Foot
status open

\begin_layout Plain Layout
Back in 1988 
\emph on
line
\emph default
 was 512 bytes, but it does not matter for the analysis.
\end_layout

\end_inset

 bytes buffer 
\emph on
line
\emph default
.
 As far as we know, this is the only real buffer overrun in the 230 lines
 of source code.
\end_layout

\begin_layout Standard
Running on 
\emph on
fingerd
\emph default
 source, boa reported overruns on 6 out of the 34 buffers.
 Next we present boa's blame for three of them, and analyze the reason for
 the reported overrun -
\end_layout

\begin_layout Paragraph
line
\end_layout

\begin_layout Standard
is the only real overrun in 
\emph on
fingerd
\emph default
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color red
line
\series default
\color inherit
 tests/realworld/fingerd/fingerd.c:85 
\end_layout

\begin_layout Standard
- 
\series bold
unsafe function call gets
\series default
 [tests/realworld/fingerd/fingerd.c:121] 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call realhostname_sa
\series default
 [tests/realworld/fingerd/fingerd.c:128] 
\end_layout

\begin_layout Standard
- 
\series bold
memchr call might read beyond the buffer
\series default
 [tests/realworld/fingerd/fingerd.c:139] 
\end_layout

\begin_layout Standard
[ ...
 10 more lines ...
 ]
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The overrun discovered by boa, and the real cause reported briefly.
 Note another result of 
\emph on
gets
\emph default
 - every other buffer access based on 
\emph on
line
\emph default
's length will be reported as an overrun.
\end_layout

\begin_layout Paragraph
rhost
\end_layout

\begin_layout Standard
is a char buffer meant to hold the host name
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color red
rhost
\series default
\color inherit
 tests/realworld/fingerd/fingerd.c:86 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call realhostname_sa
\series default
 [tests/realworld/fingerd/fingerd.c:128] 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call realhostname_sa
\series default
 [tests/realworld/fingerd/fingerd.c:128] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\series default
 [tests/realworld/fingerd/fingerd.c:128] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\series default
 [tests/realworld/fingerd/fingerd.c:128]
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This false alarm is caused by the use of 
\emph on
realhostname_sa
\emph default
, from 
\emph on
socket.h
\emph default
.
 This false alarm could be avoided if boa would model 
\emph on
socket.h
\emph default
 functions, but even now the output let the user identify the cause immediatly
 and decide manually wether this call is safe or not.
\end_layout

\begin_layout Paragraph
malloc
\end_layout

\begin_layout Standard
is a generic name for any buffer created by a malloc call, one can distinguish
 between two malloc calls by their source location (filename and line number)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color red
malloc
\series default
\color inherit
 tests/realworld/fingerd/fingerd.c:141 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias
\series default
 [tests/realworld/fingerd/fingerd.c:149] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias
\series default
 [tests/realworld/fingerd/fingerd.c:149] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias
\series default
 [tests/realworld/fingerd/fingerd.c:149] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias
\series default
 [tests/realworld/fingerd/fingerd.c:141] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias
\series default
 [tests/realworld/fingerd/fingerd.c:149] 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This blame might seem wierd at a first look, how comes buffer alias alone
 cause an overrun? But the solution appears quickly by looking at the source
 lines (141, 149) reffered by the blame -
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=141,lastline=141, firstnumber=141]{../tests/realworld/fi
ngerd/fingerd.c}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=149,lastline=151, firstnumber=149]{../tests/realworld/fi
ngerd/fingerd.c}
\end_layout

\end_inset

The programmer allocates a buffer large enough to include 
\emph on
line
\emph default
, and then iterates through the array using the 
\family typewriter
++
\family default
 operator on a pointer.
 Since boa is a flow-insensitive analyzing tool, we can not assure that
 the inceremental pointer aliasing will be limited to the buffer size -
 and therefore boa reports a possible buffer overrun.
\end_layout

\begin_layout Section
flex
\end_layout

\begin_layout Section
MD5
\end_layout

\begin_layout Standard
We have tested boa against 
\emph on
RSA Data Security, Inc.

\emph default
 implementation of
\emph on
 MD5
\emph default
, the a well known cryptographic hash function.
 Since MD5 is a cryptographic algorithm, the implementation consist of a
 lot of bitwise operations on 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "הודים"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Buffer Overrun Detection using Linear Programming and Static Analysis"
target "www.cs.wisc.edu/wisa/papers/ccs03/p351-ganapathy.pdf "

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "git repository"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "boa git repository - https://github.com/tzafrir/boa/"
target "https://github.com/tzafrir/boa/"

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "Elastic IIS"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "Locating Minimal Infeasible Constraint Sets in Linear Programs"
target "http://www.sce.carleton.ca/faculty/chinneck/docs/ChinneckDravnieks.pdf"

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BOON"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "A First Step Towards Automated Detection of Buffer Overrun Vulnerabilities"
target "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.5348&rep=rep1&type=pdf"

\end_inset


\end_layout

\end_body
\end_document
